<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Plagues Protocol]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Plagues Protocol</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 09 Dec 2025 19:49:39 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 09 Dec 2025 19:49:37 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Welcome]]></title><description><![CDATA[ <img alt="Plagues" src="assets/plagues.png" referrerpolicy="no-referrer" target="_self" style="max-width: 100%;"> A fully local, zero-trust system that splits every privileged operation into isolated, self-defending agents so a single breach doesn't mean death. The Plagues Protocol is the ultra-minimalist, zero-trust local RPC protocol that powers every single interaction inside the XRUIOS (Our Cross Platform Framework/OS/Abstraction Layer). Windows • Linux • Easy To Add Platforms • Fully Offline • Post Quantum Computing Resistant • No BS
The Plagues Protocol enforces a cryptographically-sealed boundary on the same machine between:
Untrusted side – your shell, apps, plugins (running as the logged-in user)
Trusted side – tiny, manifest-protected workers running as SYSTEM/root
All communication uses MagicOnion over OS-local channels (named pipes / Unix sockets) for zero-copy performance and zero network exposure.Trusted workers:
Verify their own executable and DLLs against a Kyber-signed manifest (Blake3 hashes) before listening
Refuse to run if tampered
Require no discovery, no TLS, no handshake — if you can open the pipe and the worker self-verified, the call is allowed
Result: Even a complete userland compromise cannot escalate or exfiltrate privileged data.
“A single breach can never conquer the machine.”
<br> <a href="https://github.com/Walker-Industries-RnD/Plagues-Protocol" target="_self" rel="noopener nofollow" class="is-unresolved"><strong></strong></a>View on GitHub • <a href="https://walkerindustries.xyz" target="_self" rel="noopener nofollow" class="is-unresolved">Walker Industries</a> • <a href="https://discord.gg/H8h8scsxtH" target="_self" rel="noopener nofollow" class="is-unresolved">Discord</a> • <a href="https://www.patreon.com/walkerdev" target="_self" rel="noopener nofollow" class="is-unresolved">Patreon</a>
<br>
Full overview → <a data-href="1. Design Philosophy" href="2.-design-principles/1.-design-philosophy.html" class="internal-link" target="_self" rel="noopener nofollow">1. Design Philosophy</a>
//The Base DLL (Ensure you also have all other DLLs for your OS at minimum)
//Also Shared References Between OSes using XRUIOS.Core;
using XRUIOS.Interfaces;
//We assume the worker "XRUIOS.Windows.PublicAccountDataHandler" was launched already at start, which should have resulted in the address "worker_addr" being populated with the API endpoint we want to //If the worker address is not exist, you can wait for it to be set but for now we handle the exception
var clientAddr = Utils.SecureStore.Get&lt;string&gt;("worker_addr");
if (clientAddr == null)
{ throw new Exception("Worker address not found in secure storage.");
}
//Take the resulting address and setup an Onion Client using var channel = Grpc.Net.Client.GrpcChannel.ForAddress(clientAddr);
var client = MagicOnion.Client.MagicOnionClient.Create&lt;XRUIOS.Interfaces.IPublicAcc&gt;(channel);
//Get the resulting data and ensure it shows something
var result = await client.GetAccInfo(Environment.UserName); Console.Write(result); Console.WriteLine($"Name: {result.Name}");
Console.WriteLine($"Folder: {result.OSFolder}");
Console.WriteLine($"Checked: {result.LastCheck}");
<br>Want to understand how to make your own services? Check Out <a data-href="1. Setup The Plagues Protocol" href="3.-using-plagues/1.-setup-the-plagues-protocol.html" class="internal-link" target="_self" rel="noopener nofollow">1. Setup The Plagues Protocol</a>Interested in using Secure Store but not so excited for Plagues Protocol?
We separated Secure Store into it's own .DLL!<br>Check It <a data-tooltip-position="top" aria-label="https://github.com/Walker-Industries-RnD/Secure-Store" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Walker-Industries-RnD/Secure-Store" target="_self">Here</a> <br>Code: <a data-tooltip-position="top" aria-label="https://raw.githubusercontent.com/non-ai-licenses/non-ai-licenses/main/NON-AI-MPL-2.0" rel="noopener nofollow" class="external-link is-unresolved" href="https://raw.githubusercontent.com/non-ai-licenses/non-ai-licenses/main/NON-AI-MPL-2.0" target="_self">NON-AI MPL 2.0</a>
Artwork: © Kennaness — NO AI training. NO reproduction. NO exceptions.<br><img style="margin-left: 20px; margin-bottom: 20px;" align="center" src="https://github.com/Walker-Industries-RnD/Malicious-Affiliation-Ban/blob/main/WIBan.png?raw=true" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Unauthorized use of the artwork — including but not limited to copying, distribution, modification, or inclusion in any machine-learning training dataset — is strictly prohibited and will be prosecuted to the fullest extent of the law.
]]></description><link>1.welcome/welcome.html</link><guid isPermaLink="false">1.Welcome/Welcome.md</guid><pubDate>Tue, 09 Dec 2025 18:11:43 GMT</pubDate><enclosure url="assets/plagues.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/plagues.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. Setup The Plagues Protocol]]></title><description><![CDATA[For this example, let's copy the format of Plagues Protocol
Download Pariah Cybersecurity's DLL from <a data-tooltip-position="top" aria-label="https://github.com/Walker-Industries-RnD/PariahCybersecurity" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Walker-Industries-RnD/PariahCybersecurity" target="_self">Here</a>
Install MagicOnion Create A Service Worker from templates (Ensuring it's the one which supports Windows/Linux and others) and name it XRUIOS.Windows.PublicAccountDataHandler, then create another named XRUIOS.Linux.PublicAccountDataHandler
These will be our service workers (As the name suggests)
Create A .DLL Project Named XRUIOS.Windows and a second named XRUIOS.Linux
These will be the DLLs responsible for platform specific code
Create a .DLL Project Named XRUIOS.Interfaces
This will contain shared definitions between platforms and the main core
Create a .DLL Named XRUIOS.Core
This will contain cross platform code and the code responsible for selecting between XRUIOS.Windows or XRUIOS.Linux at runtime
(Optional) For testing, create a CMD Project Named XRUIOS Arch Test
A simple test site for CMD related issuesThis is the only contract that crosses the Plagues boundary.// XRUIOS.Interfaces/IPublicAcc.cs
using MagicOnion; public interface IPublicAcc : IService&lt;IPublicAcc&gt;
{ UnaryResult&lt;PublicAccount&gt; GetAccInfo(string accountName);
}
// XRUIOS.Interfaces/PublicAccount.cs
using System.Runtime.Serialization; [DataContract]
public struct PublicAccount
{ [DataMember] public string Name; [DataMember] public string LastCheck; [DataMember] public string OSFolder; public PublicAccount(string name, string lastCheck, string osFolder) { Name = name; LastCheck = lastCheck; OSFolder = osFolder; }
}
Project: XRUIOS.Windows.PublicAccountDataHandler (Worker Service template)// Program.cs
using MagicOnion.Server;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using XRUIOS.Windows.PublicAccountDataHandler; var builder = WebApplication.CreateBuilder(args); builder.WebHost.ConfigureKestrel(options =&gt;
{ options.ListenLocalhost(5000, o =&gt; o.Protocols = HttpProtocols.Http2); // Later: switch to named pipe → options.ListenNamedPipe("xruios-publicacc");
}); builder.Services.AddHttpContextAccessor();
builder.Services.AddSingleton&lt;Worker&gt;();
builder.Services.AddHostedService&lt;Worker&gt;();
builder.Services.AddMagicOnion(); var app = builder.Build();
app.MapMagicOnionService&lt;PublicAccService&gt;();
app.Run();
// Worker.cs + PublicAccService
using MagicOnion;
using MagicOnion.Server;
using XRUIOS.Interfaces;
using Pariah_Cybersecurity;
using static Pariah_Cybersecurity.EasyPQC;
using System.Diagnostics; namespace XRUIOS.Windows.PublicAccountDataHandler
{ public class PublicAccService : ServiceBase&lt;IPublicAcc&gt;, IPublicAcc { private readonly Worker _worker; public PublicAccService(Worker worker) =&gt; _worker = worker; public async UnaryResult&lt;PublicAccount&gt; GetAccInfo(string accountName) =&gt; await _worker.GetAccInfo(accountName); } public class Worker : BackgroundService { private readonly ILogger&lt;Worker&gt; _logger; private readonly IHttpContextAccessor _httpContext; private readonly IServer _server; public Worker(ILogger&lt;Worker&gt; logger, IHttpContextAccessor http, IServer server) { _logger = logger; _httpContext = http; _server = server; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { await Start(); while (!stoppingToken.IsCancellationRequested) { _logger.LogInformation("Windows Plague alive: {time}", DateTimeOffset.Now); await Task.Delay(1000, stoppingToken); } } public async UnaryResult&lt;PublicAccount&gt; GetAccInfo(string accountName) { if (!await VerifyIntegrity2()) throw new Exception("Integrity Check 2 Failed"); var folder = $@"C:\Users\{accountName}\XRUIOS"; var lastCheck = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"); _logger.LogInformation("[Windows] Served account: {name}", accountName); return new PublicAccount(accountName, lastCheck, folder); } private async Task Start() { // Optional startup integrity } private async Task&lt;bool&gt; VerifyIntegrity2() { try { string exePath = Process.GetCurrentProcess().MainModule!.FileName; byte[] hash; using (var fs = new FileStream(exePath, FileMode.Open, FileAccess.Read)) hash = await FileOperations.HashFile(fs); using (var fs = new FileStream(exePath, FileMode.Open, FileAccess.Read)) return await FileOperations.VerifyHash(fs, hash); } catch { return false; } } }
}
// XRUIOS.Windows/Accounts.cs
using Grpc.Net.Client;
using MagicOnion.Client;
using XRUIOS.Interfaces; namespace XRUIOS.Windows
{ public class Accounts { public async Task&lt;PublicAccount?&gt; GetAccData(string accountName) { var addr = Utils.SecureStore.Get&lt;string&gt;("worker_addr") ?? "https://localhost:5000"; using var channel = GrpcChannel.ForAddress(addr); var client = MagicOnionClient.Create&lt;IPublicAcc&gt;(channel); return await client.GetAccInfo(accountName); } }
}
Same for Linux — just change the fallback path // XRUIOS.Core/AccountsProvider.cs
using System.Runtime.InteropServices;
using XRUIOS.Interfaces; #if WINDOWS
using XRUIOS.Windows;
#elif LINUX
using XRUIOS.Linux;
#endif namespace XRUIOS.Core
{ public static class AccountsProvider { public static async Task&lt;PublicAccount&gt; GetPublicAcc(string username) { return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? await new Windows.Accounts().GetAccData(username) : await new Linux.Accounts().GetAccData(username) ?? throw new Exception("Failed to get account data"); } }
}
using XRUIOS.Core;
using XRUIOS.Interfaces; var result = await AccountsProvider.GetPublicAcc(Environment.UserName);
Console.WriteLine($"Name: {result.Name}");
Console.WriteLine($"Folder: {result.OSFolder}");
Console.WriteLine($"Checked: {result.LastCheck}");
]]></description><link>3.-using-plagues/1.-setup-the-plagues-protocol.html</link><guid isPermaLink="false">3. Using PLAGUES/1. Setup The Plagues Protocol.md</guid><pubDate>Tue, 09 Dec 2025 17:15:36 GMT</pubDate></item><item><title><![CDATA[Kennaness]]></title><description><![CDATA[<img src="assets/kennaness.png" target="_self">]]></description><link>assets/kennaness.html</link><guid isPermaLink="false">Assets/Kennaness.png</guid><pubDate>Tue, 09 Dec 2025 15:01:31 GMT</pubDate><enclosure url="assets/kennaness.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/kennaness.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. Design Philosophy]]></title><description><![CDATA[It has exactly one rule:
Nothing that runs with user privileges is ever allowed to touch anything important. Ever.
To enforce that rule, the Plagues Protocol draws an absolute, cryptographically-enforced boundary between two worlds on the same machine:
The untrusted side (your shell, apps, future plugins, anything running as the logged-on user) The trusted side (a handful of tiny, manifest-protected service workers running as SYSTEM/root) Communication between these two sides happens only over OS-level channels (named pipes on Windows, Unix domain sockets on Linux), giving zero-copy speed while remaining isolated from network or remote access — but only if OS permissions are enforced correctly.
Before any trusted worker even starts listening, it must prove it is byte-for-byte official: it loads a Kyber-signed manifest compiled into the binary, recomputes Blake3 hashes of its own executable and loaded DLLs, and refuses to run if anything fails. The untrusted side never decides what is legitimate — only the signed manifest does. The Plagues Protocol is deliberately boring: it has no discovery protocol, no authentication handshake beyond the OS channel, no TLS layer, no fallback paths. It simply says:
“If you can open this named pipe or socket, and the worker on the other end has already verified its own signature, the call is allowed.” ⚠️ Note: To be truly secure, access to the OS channel must be restricted to the untrusted runtime only. TCP loopback alone is insufficient to enforce this. (Yes, we do this by default)
XRUIOS.Windows.PublicAccountDataHandler.exe ← standalone .NET worker
├── Worker.cs ← does Blake3 + Kyber self-check on every call
└── Program.cs ← Hosts MagicOnion over NamedPipe XRUIOS.Linux.PublicAccountDataHandler ← Linux twin
├── Worker.cs ← same self-check, returns /home/user/XRUIOS
└── Program.cs ← binds to unix:/var/run/xruios/publicacc.sock (ready)
XRUIOS.Interfaces/
├── IPublicAcc.cs ← ONE method crosses the Wall
└── PublicAccount.cs ← simple DTO: Name, LastCheck, OSFolder
Pariah_Cybersecurity/EasyPQC.cs ← Blake3 + Kyber, used for self-verification
XRUIOS Arch Test ← Test CMD Program
XRUIOS.Core/AccountsProvider.cs → Holds cross-platform logic (Non workers) and dispatches to platform-specific workers XRUIOS.Windows ← Handles Windows Specific Code
XRUIOS.Windows ← Handles Linux Specific Code
]]></description><link>2.-design-principles/1.-design-philosophy.html</link><guid isPermaLink="false">2. Design Principles/1. Design Philosophy.md</guid><pubDate>Tue, 09 Dec 2025 15:00:02 GMT</pubDate></item><item><title><![CDATA[2. The Flow Of A Plague]]></title><description><![CDATA[Here’s an updated, corrected Flow View that accurately reflects what your code actually does now — including the new SecureStore, the Windows/Linux worker address discovery, and the dual-stage self-integrity checks.All of this is written to match your XRUIOS style and ACVD tone.You should generally ensure you start all workers before the function you're looking to use starts.This is the privileged side — SYSTEM/root worker.
It is a standard .NET Worker Service that loads one of two implementations:
Windows:
XRUIOS.Windows.PublicAccountDataHandler.Worker Linux:
XRUIOS.Linux.PublicAccountDataHandler.Worker Each Worker:
Inherits BackgroundService Loads MagicOnion service PublicAccService Forwards client RPC calls directly into its internal Worker instance Performs two-stage integrity checks: VerifyIntegrity() — DLL integrity VerifyIntegrity2() — EXE integrity After binding, writes its real listening address into: Utils.SecureStore.Set("worker_addr", address);
The SecureStore:
Stores data in a per-session runtime directory: Linux: XDG_RUNTIME_DIR Windows: %LOCALAPPDATA%\XRUIOS_RUNTIME Applies per-file security: Windows: ACL locked to the current user Unix: chmod 600 This gives the untrusted side a secure, per-session channel to discover the privileged worker address.↓This is your shell, apps, UI — the untrusted side.
It calls:XRUIOS.Core.AccountsProvider.GetPublicAcc("alice");
↓It dispatches to the correct OS implementation:Windows → XRUIOS.Windows.Accounts
Linux → XRUIOS.Linux.Accounts
Each platform-specific client:
Reads the worker address from SecureStore: var addr = Utils.SecureStore.Get&lt;string&gt;("worker_addr"); Falls back to defaults if needed: Windows: https://localhost:5001 Linux: similar fallback ↓The untrusted side now:
Creates a gRPC/TCP channel to the worker:
var channel = GrpcChannel.ForAddress(addr); Creates the MagicOnion client:
var client = MagicOnionClient.Create&lt;IPublicAcc&gt;(channel); Calls into the privileged worker:
await client.GetAccInfo(username);
↓Before doing anything, it enforces self-integrity:
DLL integrity check EXE integrity check These are zero-trust boundaries — if either fails, the worker aborts.Then it constructs the OS-correct XRUIOS folder:
Windows:
C:\Users\&lt;accountName&gt;\XRUIOS Linux:
/home/&lt;accountName&gt;/XRUIOS Fills a PublicAccount struct:
account name last-access timestamp XRUIOS folder path Then returns it over MagicOnion.↓The untrusted side now has a trusted response from the privileged worker:
The real per-user XRUIOS directory A timestamp The validated account name It can now:
Render UI panels Load user configs Cache user data Display tiles / folder info No untrusted code ever touches anything privileged.This flow implements the Wall Protocol principle:
Nothing running with user privileges can ever touch anything important.
It does this through:
SecureStore → secure cross-session rendezvous Privileged worker → integrity checked, OS-native path generation MagicOnion → high-speed, zero-trust boundary RPC Platform-specific client → safe, untrusted-side requester ]]></description><link>2.-design-principles/2.-the-flow-of-a-plague.html</link><guid isPermaLink="false">2. Design Principles/2. The Flow Of A Plague.md</guid><pubDate>Tue, 09 Dec 2025 14:53:54 GMT</pubDate></item><item><title><![CDATA[PLAGUES]]></title><description><![CDATA[<img src="assets/plagues.png" target="_self">]]></description><link>assets/plagues.html</link><guid isPermaLink="false">Assets/PLAGUES.png</guid><pubDate>Tue, 09 Dec 2025 00:09:07 GMT</pubDate><enclosure url="assets/plagues.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/plagues.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[WalkerDev]]></title><description><![CDATA[<img src="assets/walkerdev.png" target="_self">]]></description><link>assets/walkerdev.html</link><guid isPermaLink="false">Assets/WalkerDev.png</guid><pubDate>Mon, 08 Dec 2025 22:03:01 GMT</pubDate><enclosure url="assets/walkerdev.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/walkerdev.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>